# 면접 알고리즘 문제 TIL (Today I Learned)

## 문제 상황: 100만개의 숫자 배열에서 최댓값 찾기

오늘 면접예상 질문문에서 "100만개의 숫자 배열이 있을 때, 가장 큰 값을 어떻게 찾을 것인가?"라는 질문을 받았다. 이 문제는 기본적인 알고리즘 지식뿐만 아니라 최적화 사고와 실용적인 접근 방식을 평가하는 질문이었다.

## 가능한 접근 방법들

### 1. 단순 선형 탐색 (Linear Search)
```java
public int findMax(int[] array) {
    if (array.length == 0) throw new IllegalArgumentException("배열이 비어있습니다");
    
    int max = array[0];
    for (int i = 1; i < array.length; i++) {
        if (array[i] > max) {
            max = array[i];
        }
    }
    return max;
}
```
- **시간 복잡도**: O(n) - 모든 요소를 한 번씩 확인
- **공간 복잡도**: O(1) - 추가 메모리 거의 사용하지 않음
- **장점**: 간단하고 직관적, 정렬되지 않은 배열에서도 동작
- **단점**: 100만개 요소를 모두 검사해야 함

### 2. 정렬 후 접근 (Sort and Access)
```java
public int findMax(int[] array) {
    if (array.length == 0) throw new IllegalArgumentException("배열이 비어있습니다");
    
    Arrays.sort(array);
    return array[array.length - 1];
}
```
- **시간 복잡도**: O(n log n) - 정렬에 소요되는 시간
- **공간 복잡도**: 정렬 알고리즘에 따라 다름
- **장점**: 정렬된 배열에서는 다른 연산도 쉽게 수행 가능
- **단점**: 단순히 최댓값만 찾는 용도라면 비효율적 (선형 탐색보다 느림)

### 3. 병렬 처리 (Parallel Processing)
```java
public int findMax(int[] array) {
    if (array.length == 0) throw new IllegalArgumentException("배열이 비어있습니다");
    
    return Arrays.stream(array).parallel().max().getAsInt();
}
```
- **시간 복잡도**: 이론적으로 O(n/p) (p는 프로세서 수)
- **장점**: 다중 코어 환경에서 성능 향상 가능
- **단점**: 작업 분할 및 결과 병합에 오버헤드 발생 가능

### 4. 상황별 최적 자료구조 (반복적 연산이 필요한 경우)
```java
// 우선순위 큐 사용
PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
for (int num : array) {
    pq.add(num);
}
int max = pq.peek(); // O(1) 시간에 최댓값 접근

// 트리셋 사용
TreeSet<Integer> ts = new TreeSet<>();
for (int num : array) {
    ts.add(num);
}
int max = ts.last(); // O(log n) 시간에 최댓값 접근
```
- **장점**: 동적 데이터 환경에서 삽입/삭제/조회 연산이 모두 효율적
- **단점**: 초기 구성에 O(n log n) 시간 필요, 추가 메모리 사용

## 면접 상황에서의 최적 답변

면접에서 이 문제에 대한 가장 좋은 답변은 **상황별 분석**을 제공하는 것이다:

1. **일회성 연산인 경우**: 단순 선형 탐색(O(n))이 가장 효율적
   - 모든 요소를 한 번씩만 확인하면 되므로 가장 간단하고 빠른 방법
   - 추가 메모리 사용 없이 문제 해결 가능

2. **반복적 연산이 필요한 경우**: 트리셋이나 우선순위 큐 같은 자료구조 고려
   - 최댓값 조회, 삽입, 삭제가 빈번하게 일어나는 동적 환경에 적합
   - O(log n) 시간에 연산 가능

3. **대용량 데이터/분산 환경**: 병렬 처리 방식 고려
   - 여러 CPU 코어를 활용하여 처리 속도 향상
   - 데이터 크기가 충분히 클 때 효과적

## 핵심 인사이트

1. **기본 원칙**: 100만 개의 숫자 배열에서 최댓값을 찾기 위해서는 최소한 모든 요소를 한 번씩 확인해야 하므로, 시간 복잡도의 하한은 O(n)이다.

2. **효율성 vs 유연성**: 단순 선형 탐색은 일반적으로 가장 효율적이지만, 동적 환경에서는 다른 자료구조가 더 유연한 해결책을 제공할 수 있다.

3. **병렬화의 가능성**: 대용량 데이터에서는 병렬 처리를 통해 실행 시간을 단축할 수 있지만, 데이터 크기와 환경에 따라 효과가 달라질 수 있다.

4. **트레이드오프 분석 능력**: 알고리즘 선택은 시간 복잡도, 공간 복잡도, 구현 복잡성, 실제 사용 시나리오 등 다양한 요소의 균형을 고려해야 한다.

## 실제 면접 현장에서 배운 점

면접 질문은 단순히 "정답"을 찾는 것보다 문제 해결 접근 방식과 상황별 분석 능력을 평가하는 경우가 많다. 이 질문에서는 다양한 방법을 제시하고, 각 방법의 장단점을 명확히 설명하며, 상황에 따른 최적의 선택을 제시하는 능력이 중요했다.

또한, 면접관은 기본적인 알고리즘 지식뿐만 아니라 대용량 데이터 처리와 최적화에 대한 실용적인 이해도 평가하려는 의도가 있었을 것이다. 이러한 종류의 질문에 효과적으로 대응하기 위해서는 이론적 지식과 실무적 경험을 모두 갖추고 있음을 보여주는 것이 중요하다.